## Python面试题

1. 说一说Python中的新式类和旧式类有什么区别。

    区别1：版本支持不同
    
    Python2.2之前：只有旧式类（classic class.也称经典类），没有新式类（new-style class）.
    Python2.2-2.7：新式类与旧式类并存, 默认使用旧式类, 使用新式类需要显式继承自object类
    Python3.0之后：只有新式类，去除了旧式类, 用户定义的所有类都隐式继承自object类
    
    推荐使用 class Foo(object) 的写法，显式继承object来定义一个类，可以兼容python2和python3.
    
    区别2：实例的类型不同
    
    在旧式类中，所有通过旧式类构造的类实例的类型均为instance，而通过内置类如list、dict等构造的实例的类型与它又完全不同，这样容易造成困惑，不利于代码的统一。在新式类中统一了类与类型，obj.__class__ == type(obj)。
    
    区别3：特性支持不同
    
    新式类支持 Python 新增的更灵活的特性，例如 __slots__类属性、__getattribute__()方法、类方法和静态方法、描述符、特征属性等。
    
    区别4：继承顺序不同
    
    在多继承时，二者采用的方法解析顺序（MRO算法）不一样，旧式类采用深度优先算法，新式类采用广度优先的C3算法。

>
> 更多有关新式类的官方文档：https://www.python.org/doc/newstyle/
>


​    

2. Python中`is`运算符和`==`运算符有什么区别？

    ```Python
    
    is 运算符 比较的是两个变量引用的对象的内存地址是否相同，即二者是否为同一个对象，等价于id(a) == id(b)
    
    == 运算符 比较的是两个变量引用的对象的值是否相同，is判断成立的两个变量的值一定也相等，但是反过来不成立
    
    ```
    
    > python中一切皆对象，python对象包括三个特性：
    > - identity（身份）：对象的内存地址，可以通过内建函数id()查看。
    > - type（类型）：对象的类型决定了保存什么样的数据，可以进行什么样的操作，可以通过内建函数type()查看。
    > - value（值）：对象包含的数据。


​    

3. Python中如何动态设置和获取对象属性？

    ```python
    from operator import attrgetter, setitem
    
    
    class Foo(object):
        pass
    
    
    foo = Foo()
    
    # 常规读写
    foo.age = 18
    print(foo.age)
    
    # 调用内置函数
    setattr(foo, 'age', 18)
    print(getattr(foo, 'age'))
    
    # 调用对象的特殊属性
    foo.__dict__['age'] = 18
    print(foo.__dict__['age'])
    
    # 调用operator模块函数
    setitem(foo.__dict__, 'age', 18)
    print(attrgetter('age')(foo))
    
    ```



4. Python如何实现内存管理？有没有可能出现内存泄露的问题?
    （1）Python的内存管理机制：引用计数、垃圾回收、内存池机制
    
    **一、引用计数**
    
    	引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。使用 `sys.getrefcount()`  可以查看对象的引用计数。
    
    **二、垃圾回收**
    
       1.  **引用计数（Reference Counting）**
    
             	引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 中的某个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0，那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了。

       2.  **标记-清除（Mark and Sweep）**
    
             	标记-清除算法是用来解决容器对象可能产生的循环引用问题，如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引用摘掉，就会得出这两个对象的有效计数。
    
       3. **分代回收（Generational Collection）** 
    
            	在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过分代回收机制 以空间换时间的方法提高垃圾回收效率。  Python将所有的对象分为0，1，2三代 ，所有新建对象都是0代，当某一代对象经历过一轮垃圾回收，依然存活，就被归入下一代，代数越高，对象被回收的概率越低。
    
    
                 	总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。
   
   **三、内存池**
   
	​	Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了内存池机制，用于管理对小块内存的申请和释放。Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改变 Python 的默认内存管理行为。
   ​	
   Python 的内存机制呈现金字塔形状:
   
   1.最底层为-1，-2 层，主要由操作系统进行操作

   2.第 0 层是 C 中的 malloc，free 等内存分配和释放函数，对大于 256K的大对象进行操作
   
   
    3.第 1 层和第 2 层是内存池，由 Python 的接口函数 PyMem_Malloc 函数实现，当对象小于 256K 时由该层直接分配内存
   
    4.第 3 层是最上层，也就是我们对 Python 对象的直接操作


   除了解释器层面的自动垃圾回收，Python也为开发者提供了gc模块用于观察和手动管理垃圾回收。

   （2）如果存在循环引用，并且被循环引用的对象定义了\__del__方法，就会发生内存泄露。

   防止内存泄漏的方法：1、使用弱引用 weakref.ref。2、强制将引用设为 None。3、另外当不使用一个对象时，使用 del object 来删除一个对象的引用计数，然后调gc.collect() 手动执行垃圾回收，另外 sys.getrefcount(obj) 可获取对象的引用计数，第三方模块 objgraph 可查看循环引用的对象图，可以用来定位内存泄漏的代码位置。

   > [参考1](https://www.cnblogs.com/51try-again/p/11099999.html)   [参考2](https://andrewpqc.github.io/2018/10/08/python-memory-management/)

5. 阐述列表和集合的底层实现原理。

    列表 list ：
    
    	在CPython中，列表被实现为长度可变的数组。
    	
    	从细节上看，Python中的列表是由对其它对象的引用组成的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，数组的大小需要重新分配。幸运的是，Python在创建这些数组时采用了指数分配，所以并不是每次操作都需要改变数组的大小。
    	
    	list和tuple在c实现上是很相似的，对于元素数量大的时候，都是一个数组指针，指针指向相应的对象，此时tuple并不会比list快。但对于小对象来说，tuple会有一个对象池做 资源缓存（resource caching），此时元组的效率高于列表。
    	时间复杂度：append和pop操作的复杂度为O(1),但insert和remove操作的复杂度为O(n)。
    
    集合 set ：
    
    	CPython使用伪随机探测(pseudo-random probing)的哈希表(hash table)作为字典的底层数据结构，集合和字典非常相似，它被实现为带有空值的字典，只有键才是实际的集合元素。此外，集合还利用这种没有值的映射做了其它的优化。因为哈希表的原因，集合的元素必须为可哈希对象，python中所有不可变对象如int、float、str、tuple都是可哈希的。
    	
    	时间复杂度：查找、插入、删除操作的时间复杂度均为 O(1)。
    
        	
> **cpython** 实现源码：  [listobject.h](https://github.com/python/cpython/blob/master/Include/listobject.h)  [listobject.c](https://github.com/python/cpython/blob/master/Objects/listobject.c )     [setobject.h](https://github.com/python/cpython/blob/master/Include/setobject.h )  [setobject.c](https://github.com/python/cpython/blob/master/Objects/setobject.c)


6. 现有字典`d = {'a': 24, 'g': 52, 'i': 12, 'k': 33}`，如何按字典中的值对字典进行排序得到排序后的字典

   ```Python
   dict(sorted(d.items(), key=lambda kv: kv[1]))
   ```


7. 实现将字符串`k1:v1|k2:v2|k3:v3`处理成字典`{'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}`。

   ```Python
   {key: value for key, value in (
       item.split(':') for item in 'k1:v1|k2:v2|k3:v3'.split('|')
   )}
   ```


8. 写出生成从`m`到`n`公差为`k`的等差数列的生成器。

    1.生成器表达式
    ```Python
    (value for value in range(m, n + 1, k))
    ```
    
    2.yield语法生成器
    ```Python
    def generate(m, n, k):
        for value in range(m, n + 1, k):
            yield value
    ```
    
    3.yield from语法生成器
    ```Python
    def generate(m, n, k):
        yield from range(m, n + 1, k)
    ```



9. 请写出你能想到的反转一个字符串的方式。

   ```Python
   string = 'hello world'
   
   # 1.切片
   print(string[::-1])
   
   # 2.内置函数reversed
   print(''.join(reversed(string)))
   
   # 3.生成器遍历
   print(''.join(string[i] for i in range(len(string) - 1, -1, -1)))
   
   # 4.递归
   def reverse_rec(content):
       return reverse_rec(content[1:]) + content[0] if len(content) > 1 else content
   
   print(reverse_rec(string))
   
   # 5.头尾互换
   def reverse_swap(content):
       lst = list(content)
       begin = 0
       end = len(lst) - 1
       while end > begin:
           lst[begin], lst[end] = lst[end], lst[begin]
           begin += 1
           end -= 1
       return ''.join(lst)
   
   print(reverse_swap(string))
   
   '''实测切片最快，reversed内置函数比它慢10倍，后面三种方法比reversed又慢6、7倍'''
   
   ```

   

10. 不使用任何内置函数，将字符串`'123'`转换成整数`123`。

   ```Python
    nums = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
    total = 0
    for ch in '123':
        total *= 10
        total += nums[ch]
    print(total)
   ```



11. 写一个返回bool值的函数，判断给定的非负整数是不是回文数。

    ```Python
    def is_palindrome(n):
        s = str(n)
        return s[::-1] == s
    ```


​    

12. 用一行代码实现求任意非负整数的阶乘。

    ```Python
    from functools import reduce
    from math import factorial
    from operator import imul
    
    num = 5
    
    # 1.内置求阶乘函数 math.factorial
    print(factorial(num))
    
    # 2.reduce函数计算累乘值，有三种方式表示自乘函数
    
    # operator.imul 自乘方法
    print(reduce(imul, range(2, num + 1), 1))
    # int.__mul__() 魔法方法
    print(reduce(int.__mul__, range(2, num + 1), 1))
    # 自写匿名函数
    print(reduce(lambda x, y: x * y, range(2, num + 1), 1))
    
    ```


​    

13. 写一个函数返回传入的整数列表中第二大的元素。

    ```Python
    def get_second(nums):
        return sorted(nums)[-2]
    ```


​    

14. 删除列表中的重复元素并保留原有的顺序。

    ```Python
    def unrepeated(lst):
        st = set()
        new = []
        for e in lst:
            # in判断时使用集合查询速度更快
            if e not in st:
                st.add(e)
                new.append(e)
        return new
    ```


​    

15. 找出两个列表中的相同元素和不同元素。

    ```Python
    def same_diff(list1, list2):
        st1 = set(list1)
        st2 = set(list2)
        # 两个集合的交集为相同元素，补集为不同元素
        return st1.intersection(st2), st1.symmetric_difference(st2)
    ```


​    

16. 列表中的某个元素出现次数占列表元素总数的半数以上，找出这个元素。


​    
​    ```Python
​    lst = ['a', 'a', 'b', 5, 'a', 'a', 5]
​    
    from collections import Counter


​    
​    # 1.collections.Counter内置类型
​    def half_ele_counter(lst):
​        return Counter(lst).most_common(1)[0][0]


​    
​    print(half_ele_counter(lst))  # 'a'


​    
​    # 2.O(n)算法
​    # 我们知道该数字出现的次数比其他所有数字出现的次数之和还要多
​    # 因此可以在遍历数组的同时记录元素出现的次数，如果数字重复，则次数加1，否则减1
​    # 当次数为0时统计下一个数，最后一个统计的数就是该数字，且此时次数等于超出数组长度一半的个数
​    def half_ele(lst):
​        half = 0
​        times = 0
​        for ele in lst:
​            if times == 0:
​                half = ele
​                times = 1
​            elif ele == half:
​                times += 1
​            else:
​                times -= 1
​        return half


​    
​    print(half_ele(lst))  # 'a'
​    ```


17. 实现对有序列表进行二分查找的算法。

    ```Python
    import bisect
    ```


​    
​    def binary_search(array, item):
​        """通用写法"""
​        left = 0
​        right = len(array) - 1
​    
        while left <= right:
            mid = (left + right) // 2
            cur = array[mid]
            if cur > item:
                right = mid - 1
            elif cur < item:
                left = mid + 1
            else:
                return mid
        return None


​    
​    def binary_search_std_lib(array, item):
​        """标准库调用"""
​        index = bisect.bisect_left(array, item)
​        if index != len(array) and array[index] == item:
​            return index
​        return None


​    
​    def binary_search_by_recursion(array, item, left, right):
​        """递归实现，首次递归需指定 left=0, right=(len(sorted_collection)-1)"""
​        if right < left:
​            return None
​        mid = left + (right - left) // 2
​        cur = array[mid]
​    
        if cur == item:
            return mid
        elif cur > item:
            return binary_search_by_recursion(array, item, left, mid - 1)
        else:
            return binary_search_by_recursion(array, item, mid + 1, right)


​    
​    if __name__ == '__main__':
​        print(binary_search([0, 5, 7, 10, 15], 5))
​        print(binary_search_std_lib([0, 5, 7, 10, 15], 5))
​        print(binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4))
​    
    ```


​    

18. 输入年月日，输出这一天是这一年的第几天。

    ```Python
    import datetime
    ```


​    
​    def which_day(year, month, day):
​        date_ = datetime.date(year, month, day)
​        # %j 表示对date对象格式化字符串为年内的第几天（001-366）
​        return int(date_.strftime('%j'))


​    
​    print(which_day(2019, 2, 28))
​    
    ```


​    

19. 统计一个字符串中各个字符出现的次数。

    ```python
    from collections import defaultdict, Counter
    ```


​    
​    string = 'hello world'
​    
    # 1.调用collections.defaultdict
    dct = defaultdict(int)
    for char in string:
        dct[char] += 1
    print(dct)
    
    # 2.调用collections.Counter
    print(Counter(string))
    ```


​    

20. 在Python中如何实现单例模式？

    ```python
    from functools import wraps
    from threading import Lock
    
    # 1.使用模块导包
    
    # Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，
    # 当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。
    # 因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。
    class Singleton(object):
        def foo(self):
            pass
    ```


​    
​    singleton = Singleton()
​    
    # 将上面的代码保存在文件 my_singleton.py 中，要使用时，
    # 直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象
    from my_singleton import singleton
    
    singleton.foo()


​    
​    # 2.使用装饰器
​    def singleton(cls):
​        """单例类的装饰器，用 @singleton 装饰后的类即为单例类"""
​    
        _instances = {}  # 实例字典，用于存放 类和对应的单例 键值对
        _locker = Lock()  # 将实例对象写入字典前上锁，以确保线程安全
    
        @wraps(cls)
        def get_instance(*args, **kwargs):
            # 已生成单例后，不需要每次都加解锁，预先判断可提升效率
            if cls not in _instances:
                with _locker:
                    if cls not in _instances:
                        _instances[cls] = cls(*args, **kwargs)
            return _instances[cls]
    
        return get_instance


​    
​    # 3.使用基类继承
​    class Singleton(object):
​        """单例类的基类，通过重写__new__()方法，其他类继承它，生成的实例即为单例"""
​        _instance = None
​        _locker = Lock()
​    
        def __new__(cls, *args, **kwargs):
            if cls._instance is None:
                with cls._locker:
                    if cls._instance is None:
                        cls._instance = super().__new__(cls)
            return cls._instance


​    
​    # 4.使用元类
​    class SingletonMeta(type):
​        """单例类的元类，通过重写__call__()方法，其他类指定它为元类后，生成的实例即为单例"""
​        _instances = {}
​        _lock = Lock()
​    
        def __call__(cls, *args, **kwargs):
            if cls not in cls._instances:
                with cls._lock:
                    if cls not in cls._instances:
                        cls._instances[cls] = super(SingletonMeta, cls).__call__(*args, **kwargs)
            return cls._instances[cls]


​    
​    if __name__ == '__main__':
​        @singleton
​        class Person:
​            pass
​    
        a = Person()
        b = Person()
        print(a, b, a is b)


​    
​        class Person(Singleton):
​            pass
​    
        c = Person()
        d = Person()
        print(c, d, c is d)


​    
​        class Person(metaclass=SingletonMeta):
​            pass
​    
        e = Person()
        f = Person()
        print(e, f, e is f)
    
    ```
    > 更多示例：[stack overflow](https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python)   [官网装饰器样例实现](https://wiki.python.org/moin/PythonDecoratorLibrary#Singleton)


​    
​    
21. 下面的代码会输出什么。

    ```Python
    class A:
        
        def __init__(self, value):
            self.__value = value
        
        @property
        def value(self):
            return self.__value
    ```


​    
​    a = A(1)
​    a.__value = 2
​    print(a.__value)
​    print(a.value)
​    ```
​    
    ```python
    2
    1
    # 在给对象 a 赋值 __value属性 后，a.__dict__ 返回 {'_A__value': 1, '__value': 2}
    # 双下划线开头的私有属性，只允许类本身访问，子类也不行，在类的内部被定义后，它被自动转换为 _类名__属性名，访问 self.__属性名 时会将它转换为 self._类名__属性名。
    # 在类的外部定义和访问的 __属性名 ，均为新的实例属性，属性名不会被解释器转换。
    ```
    > 官网说明：[下划线标识符]( https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#reserved-classes-of-identifiers )



22. 实现一个记录函数执行时间的装饰器。

    ```python
    import time
    from functools import wraps
    ```


​    
​    def time_it(fn):
​        """函数调用执行用时装饰器"""
​    
        @wraps(fn)
        def wrapper(*args, **kwargs):
            start = time.time()
            result = fn(*args, **kwargs)
            end = time.time()
            print(f'函数{fn.__name__}被调用，共计用时{end - start:.2f}秒。')
            return result
    
        return wrapper
    ```


​    

23. 写一个遍历指定目录下指定后缀名的文件的函数。

    ```Python
    import os
    
    def get_suffix_files(src, suffix):
        """
        获取src目录下所有后缀为suffix的文件列表
        suffix以点号.开始，返回的列表中存放所有文件的绝对路径
        """
        file_list = []
    
        for cur_dir, dirs, files in os.walk(src):
            if files:
                file_list.extend(
                    map(lambda f: os.path.join(cur_dir, f),
                        filter(lambda f: f.endswith(suffix), files)))
    
        return file_list
    ```


24. 有如下所示的字典，请将其转换为CSV格式。

    转换前：
    
    ```Python
    dict_corp = {
        'cn': {'id': 1, 'name': '土豆', 'desc': '土豆', 'price': {'gold': 20, 'kcoin': 20}},
        'en': {'id': 1, 'name': 'potato', 'desc': 'potato', 'price': {'gold': 20, 'kcoin': 20}},
        'kr': {'id': 1, 'name': '감자', 'desc':'감자', 'price': {'gold': 20, 'kcoin': 20}},
        'jp': {'id': 1, 'name': 'ジャガイモ', 'desc': 'ジャガイモ', 'price': {'gold': 20, 'kcoin': 20}},
    }
    ```
    
    转换后：
    
    ```CSV
    language,id,name,desc,gold,kcoin  
    cn,1,土豆,土豆,20,20
    en,1,potato,potato,20,20
    kr,1,감자,감자,20,20
    jp,1,ジャガイモ,ジャガイモ,20,20
    ```
    
    ```Python
    string = 'language,id,name,desc,gold,kcoin'
    items = []
    
    for language, value in dict_corp.items():
        item = []
        item.append(language)
        for v in value.values():
            if isinstance(v, dict):
                item.extend(map(str, v.values()))
            else:
                item.append(str(v))
        items.append(item)
    
    for item in items:
        string += '\n' + ','.join(item)
    
    print(string)
    
    ```



25. 有如下所示的日志文件，请用Python程序或Linux命令打印出独立IP并统计数量。

    ```
    221.228.143.52 - - [23/May/2019:08:57:42 +0800] ""GET /about.html HTTP/1.1"" 206 719996
    218.79.251.215 - - [23/May/2019:08:57:44 +0800] ""GET /index.html HTTP/1.1"" 206 2350253
    220.178.150.3 - - [23/May/2019:08:57:45 +0800] ""GET /index.html HTTP/1.1"" 200 2350253
    218.79.251.215 - - [23/May/2019:08:57:52 +0800] ""GET /index.html HTTP/1.1"" 200 2350253
    219.140.190.130 - - [23/May/2019:08:57:59 +0800] ""GET /index.html HTTP/1.1"" 200 2350253
    221.228.143.52 - - [23/May/2019:08:58:08 +0800] ""GET /about.html HTTP/1.1"" 206 719996
    221.228.143.52 - - [23/May/2019:08:58:08 +0800] ""GET /news.html HTTP/1.1"" 206 713242
    221.228.143.52 - - [23/May/2019:08:58:09 +0800] ""GET /products.html HTTP/1.1"" 206 1200250
    ```

    ```Python
    # python方法
    import re
    from collections import defaultdict
    
    IP_REG = re.compile(r'(\d{1,3}\.){3}\d{1,3}')
    
    with open('demo.log', 'r') as file:
        counter = defaultdict(int)
        for line in file:
            ip = IP_REG.match(line).group(0)
            if ip:
                counter[ip] += 1
    for ip in counter:
        print(ip, counter[ip])
		
	
	# linux命令:
      
	   grep -Eio "([0-9]{1,3}\.){3}[0-9]{1,3}" demo.log | sort -n | uniq -c | sort -nr
	   
	   参数解释：
	   
	   grep命令 用于文本搜索
	   
		   -E：使用扩展正则匹配，可使用 | 分割多个pattern实现多表达式匹配
	   
		   -i：忽略大小写
	   
		   -o：只显示匹配的部分
	   
	   sort命令 用于排序
	   
		   -n：数值排序
	   
		   -r：倒序排序
	   
	   uniq命令 用于去重，只会过滤相邻的匹配行，因此需先进行sort排序
	   
		-c：显示重复次数
	```



26. 请写出从HTML页面源代码中获取a标签href属性的正则表达式。

    ```python
    r'<a[^>]+href=["\'](.*?)["\']'
    ```




27. 正则表达式对象的`search`和`match`方法有什么区别？

     [`re.match()`](https://docs.python.org/zh-cn/3/library/re.html#re.match) 用于检查字符串开头，而 [`re.search()`](https://docs.python.org/zh-cn/3/library/re.html#re.search) 检查字符串的任意位置。
    
    换句话说，`match()`方法只会从第一个字符开始匹配，一旦遇到不匹配的就匹配失败，返回`None`，而`search()`则会扫描整个字符串进行匹配，一旦遇到匹配成功的就返回 [匹配对象](https://docs.python.org/zh-cn/3/library/re.html#match-objects)
    
    例如：
    
    ```python
    >>> re.match("c", "abcdef")    # 匹配失败
    >>> re.search("c", "abcdef")   # 匹配成功
    <re.Match object; span=(2, 3), match='c'>
    ```
    
    在 [`search()`](https://docs.python.org/zh-cn/3/library/re.html#re.search) 中，可以将 `'^'` 放在第一位，用来限制字符串开头必须是 `'^'` 之后的字符
    
    ```python
    >>> re.match("c", "abcdef")    # 匹配失败
    >>> re.search("^c", "abcdef")  # 匹配失败
    >>> re.search("^a", "abcdef")  # 匹配成功
    <re.Match object; span=(0, 1), match='a'>
    ```
    
    注意： 即便是 [`MULTILINE`](https://docs.python.org/zh-cn/3/library/re.html#re.MULTILINE) 多行模式， [`re.match()`](https://docs.python.org/zh-cn/3/library/re.html#re.match) 也只匹配字符串的开始位置，而不匹配每行开始。但使用 [`search()`](https://docs.python.org/zh-cn/3/library/re.html#re.search) 和以 `'^'` 开始的正则表达式则会匹配每行的开始
    
    ```python
    >>> re.match('X', 'A\nB\nX', re.MULTILINE)  # 匹配失败
    >>> re.search('^X', 'A\nB\nX', re.MULTILINE)  # 匹配成功
    <re.Match object; span=(4, 5), match='X'>
    ```
    
    > 官方对比：[search() vs. match()](https://docs.python.org/zh-cn/3/library/re.html#search-vs-match)




28. 当做个线程竞争一个对象且该对象并非线程安全的时候应该怎么办？

    ```Python
    使用互斥锁，对共享数据进行锁定，保证同一时刻只能有一个线程去操作。
    
    import threading
    
    # 创建锁
    mutex = threading.Lock()
    
    # 上锁
    mutex.acquire()
    
    ...
    
    # 释放锁
    mutex.release()
    ```




29. 说一下死锁产生的条件以及如何避免死锁的发生。

    ```Python
    当一个线程没有释放锁，其他线程一直等待对方释放锁时会产生死锁，造成应用程序的停止响应
    
    检查死锁产生的代码位置，在合适的地方释放锁可以避免死锁的发生
    ```




30. 请阐述TCP和UDP的优缺点。

    TCP优点： 可靠，面向连接
    
    TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有发送应答、超时重传、错误校验、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 
    
    TCP缺点： 速度慢，资源占用高，易被攻击，难以改进
    
    TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。另外TCP设计过于冗余，大量控制机制内置在系统协议栈中，极难对其进行改进。
    
    UDP优点： 速度快，资源占用低，比TCP稍安全，易于改进
    
    UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击等。应用设计时能够对握手过程进行精简，减少网络通信往返次数，能够对TLS加解密过程进行优化，改进比较方便。
    
    UDP缺点： 不可靠，面向非连接
    
    因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 
    
    
    
    应用场景：
    TCP:需要保证数据可靠性、速度可以相对比较慢
        文件传输协议：HTTP、HTTPS、FTP，邮件传输协议：POP、SMTP，远程登录协议：SSH、Telnet等大部分互联网应用。
    UDP：对数据可靠性要求不高、网络速率尽量高
    	即时通讯（音视频数据）如 WebRTC 基于网页的实时视频会议，实时游戏 如 CS、我的世界 采用自定义重传策略的可靠UDP协议-RakNet，物联网通信协议，局域网内的如 TFTP简单文件传输、广播、多播等。
    
    
    
    总结：
    TCP面向字节流，UDP面向报文，前者通过一系列控制机制来保证它是一个面向连接的点到点可靠协议，后者不可靠，但支持一对多，具有较好的实时性，工作效率更高，今后网速的提升使它在越来越多的场景下取代TCP。

 

31. HTTP请求的GET和POST有什么区别？

    1.url不一样：
    	GET 请求，请求的数据会附加在 URL 之后，以?问号分割 URL 和传输数据，多个参数用&连接。URL 的编码格式采用的是 ASCII 编码，而不是 unicode，即所有非 ASCII 字符都要编码之后再传输。
    	POST 请求：POST 请求会把请求的数据放置在 HTTP 的请求体中。
    
    因此，GET 请求的数据会暴露在地址栏中，而 POST 请求则不会。
    
    2.传输数据的大小：
    	在 HTTP 规范中，没有对 URL 的长度和传输的数据大小进行限制。但是在实际开发过程中，对于 GET，特定的浏览器和服务器对 URL 的长度有限制。因此，在使用 GET 请求时，传输数据会受到 URL 长度的限制。
    	对于 POST，由于不是 URL 传值，理论上是不会受限制的，但是实际上各个服务器会规定对 POST
    提交数据大小进行限制，Apache、IIS 都有各自的配置。
    
    3.安全性：
    	POST 的安全性比 GET 的高。这里的安全是指真正的安全，而不同于上面 GET 提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过 GET 请求，用户名和密码都会暴露再 URL 上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET 请求提交的数据还可能会造成 Cross-site request frogery 攻击。
    
    4.效率：
    	GET 比 POST 效率高。
    	POST 请求的过程：
     1.浏览器请求 tcp 连接（第一次握手）
     2.服务器答应进行 tcp 连接（第二次握手）
     3.浏览器确认，并发送 post 请求头（第三次握手，这个报文比较小，所以 http 会在此时进行
    第一次数据发送）
     4.服务器返回 100 continue 响应
     5.浏览器开始发送数据
     6.服务器返回 200 ok 响应
    GET 请求的过程：
     1.浏览器请求 tcp 连接（第一次握手）
     2.服务器答应进行 tcp 连接（第二次握手）
     3.浏览器确认，并发送 get 请求头和数据（第三次握手，这个报文比较小，所以 http 会在此时
    进行第一次数据发送）
     4.服务器返回 200 OK 响应



32. 说一些你知道的HTTP响应状态码。

    ```Python
    1开头：代表请求已被接受，需要继续处理，一般生产环境不使用。
    
    2开头：代表请求已成功被服务器接收、理解、并接受。
    200 OK （请求成功）
    201 Created （新增资源成功）。
    
    3开头：请求重定向
    301 Moved Permanently （永久重定向）
    302 Found （临时重定向）
    304 Not Modified （资源没有改变，只返回消息头，使用缓存资源）
    
    4开头：客户端请求有错误
    404 Not Found （服务器无法找到被请求资源）
    403 Forbidden （服务器拒绝访问）
    405 Method Not Allowed (客户端请求方法被禁止)
    400 Bad Request (客户端请求错误，服务器无法理解)
    
    5开头：服务器端出现错误
    500 Internal Server Error （服务器发生不可预期的错误）
    503 Server Unavailable （由于临时维护或过载，服务器当前无法处理请求）
    ```




33. 简单阐述HTTPS的工作原理。

    ```Python
    HTTPS 其实就是在 HTTP 跟 TCP 中间加多了一层加密层 TLS/SSL。SSL 是个加密套件，负责对 HTTP
    的数据进行加密。TLS 是 SSL 的升级版。现在提到 HTTPS，加密套件基本指的是 TLS。原先是应用层将
    数据直接给到 TCP 进行传输，现在改成应用层将数据给到 TLS/SSL，对数据进行混合加密后，再给到 TCP 进行
    传输。
    
    ```
    
    > [TLS/SSL加密协议](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)   [图解TLS//SSL协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)   [图解数字签名](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)




34. 阐述Django项目中一个请求的生命周期。

    ```Python
    1. 当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端。
    
    2. 请求先经过Django中的wsgi模块，首先被转化成一个 HttpRequest 对象，再经过Django的 Request 请求中间件，请求中间件处理完毕，根据url进行路由映射表匹配，url一旦匹配成功，将请求对象传递给 View 视图中间件，视图中间件处理完毕，进入下一步 view 视图函数处理。
    
    3. 执行视图函数，业务处理（通过ORM的 Model 模块类进行数据库读写操作），返回 HTTPResponse 对象给Django，再通过一系列的 Response 响应中间件，然后Django把客户端想要的数据作为一个字符串返回给客户端。
    
    4. 客户端浏览器接收到返回的数据,经过渲染后显示给用户。
    
    ```
    
     ![img](https://upload-images.jianshu.io/upload_images/12899159-a885a8680c58321e.png?imageMogr2/auto-orient/strip|imageView2/2/w/446/format/webp) 




35. Django项目中实现数据接口时如何解决跨域问题。

    ```Python
    项目中前端服务器与后端服务器分处不同的域名，需要为后端服务器添加跨域访问的支持。
    
    Django项目中可以使用django-cors-headers扩展进行跨域请求设置。
    
    1）安装
    pip install django-cors-headers
    
    2）注册应用
    INSTALLED_APPS = (
        ...
        'corsheaders',
        ...
    )
    
    3）注册中间件
    MIDDLEWARE = [
        # 将CORS中间件添加到中间件的第一个
        'corsheaders.middleware.CorsMiddleware',
        ...
    ]
    
    4）添加跨域请求白名单
    # 设置白名单，凡是出现在白名单中的域名，都可以向服务器发起跨域请求
    CORS_ORIGIN_WHITELIST = (
        '127.0.0.1:8080',
    )
    CORS_ALLOW_CREDENTIALS = True  # 允许携带cookie
    
    # 另外也可以自己写一个响应中间件，响应头中添加"Access-Control-Allow-Origin"字段即可
    
    ```
    
    > [django-cors-headers 扩展](https://github.com/adamchainz/django-cors-headers)   [参考文章](https://www.jianshu.com/p/c75cbca33d77)




36. Django项目中如何对接Redis高速缓存服务。

    ```Python
    1）服务端系统安装redis后，开启本地redis服务
    
    2）pip install django-redis
    
    3）配置项将redis设为django默认的缓存服务器
    CACHES = {
        "default": {  # 默认
            "BACKEND": "django_redis.cache.RedisCache",
            "LOCATION": "redis://192.168.103.210:6379/0",
            "OPTIONS": {
                "CLIENT_CLASS": "django_redis.client.DefaultClient",
            }
        }
    }
    
    4.导入模块即可进行缓存读写操作
    
    from django.core.cache import cache
    
    value = cache.get(key)	# 读取
    cache.set(value, key, expire)	# 写入，设置过期时间
    
    ```




37. 请说明Cookie和Session之间的关系。

    ```Python
    1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。
    2、cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使
    用 session。
    3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能。考虑到减轻服
    务器性能方面，应当使用 cookie。
    4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie，而 session 没有大小的限制。
    5、建议：将登陆信息等重要信息存放为 session ，其他信息如果需要保留，可以放在 cookie 中。
    ```




38. 说一下索引的原理和作用。

    ```Python
    数据库索引，是数据库中一种事先对数据库表中一列或多列数据进行排序的存储结构，可以协助数据库更加快速地查询、更新数据库表中数据。
    
    原理：未经排序的数据库字段数据需要逐一进行线性查找，时间复杂度为O(N），排序之后可以对其使用二分法查找，时间复杂度降为ln(N)。各大数据库索引的实现通常使用 B树。B树 索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据，相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。
    
    作用：加快查询速度，同时也需要占用额外的磁盘空间。
    ```




39. 是否使用过Nginx实现负载均衡？用过哪些负载均衡算法？

    **1、轮询  round robin（默认）** 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除， 适用于后台机器性能一致的情况。
    
    ```javascript
    upstream backserver {
    server 192.168.0.14;
    server 192.168.0.15;
    }
    ```
    
    **2、加权轮询 weight **  根据权重来分发请求到不同的机器中， 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
    
    ```javascript
    upstream backserver {
    server 192.168.0.14 weight=10;
    server 192.168.0.15 weight=10;
    }
    ```
    
    **3、IP绑定 ip_hash  ** 每个请求按访问ip的hash值分配，这样每个访客固定访问一个后端服务器，可以解决session会话一致性的问题。 
    
    ```javascript
    upstream backserver {
    ip_hash;
    server 192.168.0.14:88;
    server 192.168.0.15:80;
    }
    ```
    
    **4、fair（第三方）** 按后端服务器的响应时间来分配请求，响应时间短的优先分配。
    
    ```javascript
    upstream backserver {
    server server1;
    server server2;
    fair;
    }
    ```
    
    **5、url_hash（第三方）** 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
    
    ```javascript
    upstream backserver {
    server squid1:3128;
    server squid2:3128;
    hash $request_uri;
    hash_method crc32;
    }
    ```




40. 一个保存整数（int）的数组，除了一个元素出现过1次外，其他元素都出现过两次，请找出这个元素。

    **利用按位异或运算的特性：**
    **1.一个整数与 0 进行异或运算后值不变，a ^ 0 == a**
    **2.一个整数与 自身 进行异或运算后等于0，a ^ a == 0**
    **3.异或运算满足交换律和结合律，a ^ b ^ a == (a ^ a) ^ b == 0 ^ b == b**
    
    ```Python
    def find_single(nums):
        """找出整数数组中只出现一次的数字"""
        a = 0
        for n in nums:
            a ^= n
        return a
    ```




41. 有12个外观相同的篮球，其中1个的重量和其他11个的重量不同（有可能轻有可能重），现在有一个天平可以使用，怎样才能通过最少的称重次数找出这颗与众不同的球。

    ```Python
    最少称三次找出：
    
    我们将这12个球分三组，每组四个,第一组编号 1 2 3 4，第二组 5 6 7 8，第三组 A B C D. 
    
    称重过程如下图：
    ```

![三步称重](https://github.com/BruceLee569/PublicSource/blob/master/images/interview/weight_3_step.png)
